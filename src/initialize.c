/********************************************************************
 *
 * KMC MODEL
 *
 * Author: R.H.J. Gerritsen
 *
 * Created on: 08-01-2020
 * 
 * During the initialization model parameters are read from file and
 * key variables are allocated and initialized. Also the neighbourlist
 * is setup here.
 *******************************************************************/

#include "main.h"
#include "functions.h"

#define max(a,b) (((a) > (b)) ? (a) : (b))

/*************************************
 *    MODEL PARAMETERS               *
 *************************************/
 /* RNG SEED*/
long int SEED;

/* General Model Parameters */
int nrOfSteps;
int maxNeighbours;
int nrOfSites;
double rCutOff;
int nrOfpTypes;
double* DOS_mu;
double* DOS_sigma;
int* nrOfParticlesOfType;
double* chargeOfType;
double* v0OfType;
double* alphaOfType;

/* Not in input file generated by program */
int nrOfParticles;
double maxXYZ[3]; // will store the maximum dimensions for x,y,z direction

/* Miller-Abrahams Rate */
double v0;
double alpha;
double kBT;


/* Electric Field */
double E_Field;
double electrodeEnergy_neg;

/*************************************
 *    GLOBAL VARIABLES               *
 *************************************/
/* Graph, Rates and Site Locations */
int** neighbourList;             // 2D-array containing the neighbourlist of the graph
double*** rateList;               // 2D-array containing the rates corresponding to the neighbour in neighbourList
double** siteXYZ;                // 2D-array containing the (x,y,z) coordinate of every site
double** siteEnergy;              // 1D-array containing the siteEnergy
int** siteIsOccupied;             // 1D-array storing the current state of a site, occupied or not

/* Next Event List */
double* nextEventRates;          // 1D-array row i corresponds to the rate of event i
int** nextEvent;                 // 2D-array row i gives the particle to update and to which site it is moved

/* Store results */
double** siteOccupation;           // 1D-array storing the site occupation
double** lengthOfPath; 
double* driftVelocity;
double* mobility;

/* State variables */
int* particlePositions;
int* particleTypes;
double totalTime = 0;

int readSites(char* filename) {
	/************************************************************************************
	 * Input   : a filename
	 * Output  : Nothing important
	 * Procedure: Read the locations of the sites from a file
	 ************************************************************************************/
	FILE* fp;
	char str[1000];
	char c;
	float x, y, z;
	int count = 0;
	int nrElem;

	fp = fopen(filename, "r");
	if (fp == NULL) {
		printf("Could not open file %s", filename);
		exit(1);
	}

	/* Get number of sites (lines in file) and check against model parameters */
	for (c = getc(fp); c != EOF; c = getc(fp))
		if (c == '\n') // Increment count if this character is newline 
			count = count + 1;
	if (count != nrOfSites) {
		printf("Number of sites in file %s does not match nrOfSites in the model parameters.\n", filename);
		return 1;
	}
	else {
		printf("Number of sites matches.\n");
	}

	/* Now read the actual values */
	rewind(fp);
	for (count = 0; count < nrOfSites; count++) {
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%f %f %f", &x, &y, &z);
		siteXYZ[count][0] = x;
		siteXYZ[count][1] = y;
		siteXYZ[count][2] = z;
	}	

	fclose(fp);
	return 0;
}

int setupSiteEnergies(void) {
	/* Does what it says, assigns site energies to the siteEnergy variable. */
	for (int j = 0; j < nrOfpTypes; j++){
		for (int i = 0; i < nrOfSites; i++) {
			siteEnergy[j][i] = genrand_Normal(DOS_mu[j],DOS_sigma[j]);
		}
	}
	return(0);
}

int setupNeighboursAndRates(void) {
	/************************************************************************************
	 * Procedure: Create the neighbourlist and compute the jumping rates.
	 ************************************************************************************/
	double dist;
	int i, j, k;
	int c_neighbour;
	int maxN = 0;

	/* SETUP: neighbours and rates */
	for (i = 0; i < nrOfSites; i++) {
		c_neighbour = 0;
		/* Add the neighbours whitin rCutOff to the neighbourlist. */
		for (j = 0; j < nrOfSites; j++) {
			if (i != j) {
				dist = distance_PBC_3D_noX(siteXYZ[i],siteXYZ[j]);
				if (dist <= rCutOff) {
					neighbourList[i][c_neighbour] = j;
					for(int pType =0; pType < nrOfpTypes; pType++){
						rateList[pType][i][c_neighbour] = hopRate(dist,  correctedPBC_1D(siteXYZ[j][0]-siteXYZ[i][0], maxXYZ[0]), chargeOfType[pType] , siteEnergy[pType][i], siteEnergy[pType][j], v0OfType[pType], alphaOfType[pType]); 
					}
					c_neighbour++;
					maxN = max(c_neighbour, maxN);
					if (c_neighbour == maxNeighbours) {
						printf("Number of maximum neighbours is too small!\n");
					}
				}
			}

		}

		/* SETUP: electrodes */
		if (siteXYZ[i][0] > maxXYZ[0]-5.0){
			neighbourList[i][c_neighbour] = -1; // The negative electrode
			for(int pType =0; pType < nrOfpTypes; pType++){
				rateList[pType][i][c_neighbour] = (pType==0)*hopRate(correctedPBC_1D(maxXYZ[0]-siteXYZ[i][0], maxXYZ[0]),  correctedPBC_1D(maxXYZ[0]-siteXYZ[i][0], maxXYZ[0]), chargeOfType[pType] , siteEnergy[pType][i], electrodeEnergy_neg, v0OfType[pType], alphaOfType[pType]); 
			}
			c_neighbour++;
		}
		if (siteXYZ[i][0] < 5.0){
			neighbourList[i][c_neighbour] = -2; // The positive electrode
			for(int pType =0; pType < nrOfpTypes; pType++){
				rateList[pType][i][c_neighbour] = (pType==1)*hopRate(correctedPBC_1D(siteXYZ[i][0], maxXYZ[0]),  correctedPBC_1D(siteXYZ[i][0], maxXYZ[0]), chargeOfType[pType] , siteEnergy[pType][i], 1.5, v0OfType[pType], alphaOfType[pType]); 
			}
			c_neighbour++;
		}

		/* fill the rest of the row with -11's */
		for (k = c_neighbour; k < maxNeighbours; k++) {
			neighbourList[i][k] = -11;
			for(int pType =0; pType<nrOfpTypes;pType++){
				rateList[pType][i][k] = 0;
			}
		}
	}
	printf("Maximum neighbours: %d\n", maxN);
	return(0);

}


void readModelParameters(char* filename) {
	/************************************************************************************
	* Input   : a filename
	* Procedure: Read the modelParamters from a file.
	************************************************************************************/
	FILE* fp;
	char str[1000];
	char junk[1000];
	char c;
	int count = 1;
	int nrElem;

	fp = fopen(filename, "r");
	if (fp == NULL) {
		printf("Could not open file %s", filename);
		exit(1);
	}

	/* Read the values */
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %d", &junk, &SEED);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %d", &junk, &nrOfSteps);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %d", &junk, &maxNeighbours);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %d", &junk, &nrOfSites);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &rCutOff);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &maxXYZ[0]);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &maxXYZ[1]);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &maxXYZ[2]);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %d", &junk, &nrOfpTypes);
	
	alloc_memory_parameter_reading(); // allocate memory for the DOS variables and such
	for(int i = 0; i< nrOfpTypes; i++){
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %d", &junk, &nrOfParticlesOfType[i]);
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %lf", &junk, &DOS_mu[i]);
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %lf", &junk, &DOS_sigma[i]);
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %lf", &junk, &chargeOfType[i]);
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %lf", &junk, &v0OfType[i]);
		fgets(str, 1000, fp);
		nrElem = sscanf(str, "%s %lf", &junk, &alphaOfType[i]);		
	}


	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &kBT);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &E_Field);
	fgets(str, 1000, fp);
	nrElem = sscanf(str, "%s %lf", &junk, &electrodeEnergy_neg);
	fclose(fp);

	nrOfParticles = 0;
	for(int pType =0; pType < nrOfpTypes; pType++){
		nrOfParticles += nrOfParticlesOfType[pType];
	}
}


void initialise(void) {
	/* Initialize all the variables. */
	int i, j;
	int select;

	totalTime = 0;
	
	alloc_memory(); 

	init_genrand(SEED); // Initialize random number generator
	
	readSites("../input/sites.txt"); // Read the site locations from a file

	setupSiteEnergies(); // Generate random site energies

	setupNeighboursAndRates(); // Setup the neigbourlist and compute all rates


	/* Initialize the results arrays with zeros. */
	for (int pType =0; pType < nrOfpTypes; pType++){
		for (i = 0; i < nrOfSites; i++) {
			siteOccupation[pType][i] = 0;
		}
	}
	for (i = 0; i < nrOfParticles; i++) {
		for (int j = 0; j < 3; j++) {
			lengthOfPath[i][j] = 0;
		}
	}
	/* Initialize the initial positions of the particles */
	for (i = 0; i < nrOfParticles; i++) {
		select = (int) (1.0 * nrOfSites * genrand_Real());
		for (j = 0; j < i; j++) { // make sure all starting points are unique
			if (select == particlePositions[j]) {
				select = (int)(1.0 * nrOfSites * genrand_Real());
				j = 0;
			}
		}
		particlePositions[i] = select;
	}
	/* Initialize the Particle types */
	int step = 0;
	for (int pType =0; pType < nrOfpTypes; pType++){
		for(i =0; i < nrOfParticlesOfType[pType]; i++){
			particleTypes[step] = pType;
			step++;
		}
	}
	/* Check if we initialized all particles */
	if (step == nrOfParticles){
		printf("All particles initialized.\n");
	}else{
		printf("Initialization of particle types went horribly wrong!\n");
		exit(1);
	}

	/* Initialize the occupied array */
	for( int pType = 0; pType < nrOfpTypes; pType++){
		for (i = 0; i< nrOfSites; i++){
			siteIsOccupied[pType][i] = 0;
		}
	}
	for (i = 0; i < nrOfParticles; i++){
		siteIsOccupied[particleTypes[i]][particlePositions[i]] = 1;
	}

	printf("Initialization and setup is done.\n");
}